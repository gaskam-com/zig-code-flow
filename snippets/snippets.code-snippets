{
    // Basic Snippets

    "zig love": {
        "prefix": "ziglove",
        "body": [
            "const std = @import(\"std\");",
            "",
            "pub fn main() !void {",
            "\tstd.debug.print(\"I love ZIG!\\n\");",
            "}",
            ""
        ],
        "description": "Prints 'I love ZIG!' to the console",
        "isFileTemplate": true
    },
    "launch": {
        "prefix" : ["launch", "startup"],
        "body" : [
            "const std = @import(\"std\");",
            "",
            "pub fn main() !void {",
            "\t$0",
            "}",
            ""
        ],
        "description" : "Initializes a main function",
        "isFileTemplate": true
    },
    "import": {
        "prefix": "import",
        "body": [
            "const ${1:name} = @import(\"${2:file}\");"
        ],
        "description": "Import a module using @import"
    },
    "import std": {
        "prefix": ["import_std", "imps"],
        "body": [
            "const std = @import(\"std\");"
        ],        
        "description": "Import the standard library"
    },
    "import builtin": {
        "prefix": ["import_builtin", "impb"],
        "body": [
            "const builtin = @import(\"builtin\");"
        ],
        "description": "Import the builtin module"
    },

    // Functions

    "fn": {
        "prefix": "fn",
        "body": [
            "fn ${1:name}($2)${3| !, |}${4:void} {",
            "\t$TM_SELECTED_TEXT$0",
            "}"
        ],
        "description": "Create a function with optional error union return type"
    },
    "generic fn": {
        "prefix": "fn_generic",
        "body": [
            "fn ${1:name}(comptime ${2:T}: ${3:type}, $4)${5| !, |}${6:type} {",
            "\t$TM_SELECTED_TEXT$0",
            "}"
        ],
        "description": "Create a generic function with compile-time type parameter"
    },
    "pub fn": {
        "prefix": "pub_fn",
        "body": [
            "pub fn ${1:name}($2)${3| !, |}${4:type} {",
            "\t$TM_SELECTED_TEXT$0",
            "}"
        ],
        "description": "Create a public function with optional error union return type"
    },
    "inline fn": {
        "prefix": "inline_fn",
        "body": [
            "inline fn ${1:name}($2)${3| !, |}${4:type} {",
            "\t$TM_SELECTED_TEXT$0",
            "}"
        ],
        "description": "Create an inline function"
    },
    "nested fn": {
        "prefix": "nested_fn",
        "body": [
            "const ${1:name} = struct {",
            "\tfn ${2:inner}($3)${4| !, |}${5:void} {",
            "\t\t$TM_SELECTED_TEXT$0",
            "\t}",
            "}.$2;"
        ],
        "description": "Create a nested function inside a struct"
    },

    // Debug

    "debug": {
        "prefix": "debug",
        "body": [
            "std.debug.print(\"${1:fmt}\", .{ $0 });"
        ],
        "description": "Print debug output using std.debug.print"
    },

    // Variables

    "comptime": {
        "prefix": "comptime",
        "body": [
            "comptime ${1:name} = $0;"
        ],
        "description": "Define a compile-time variable"
    },
    "var": {
        "prefix": "var",
        "body": [
            "var ${1:name}: ${2:type} = $0;"
        ],
        "description": "Declare a variable with explicit type"
    },
    "const": {
        "prefix": "const",
        "body": [
            "const ${1:name} = $0;"
        ],
        "description": "Declare a constant with inferred type"
    },
    "const type": {
        "prefix": "const_type",
        "body": [
            "const ${1:name}: ${2:type} = $0;"
        ],
        "description": "Declare a constant with explicit type"
    },

    // Data Structures
    
    "struct": {
        "prefix": "struct",
        "body": [
            "struct {",
            "\t$TM_SELECTED_TEXT$0",
            "}"
        ],
        "description": "Create an anonymous struct"
    },
    "const struct": {
        "prefix": "const_struct",
        "body": [
            "const ${1:name} = struct {",
            "\t$TM_SELECTED_TEXT$0",
            "};"
        ],
        "description": "Create a named struct type"
    },
    "enum": {
        "prefix": "enum",
        "body": [
            "const ${1:name} = enum(${2:type}) {",
            "\t$TM_SELECTED_TEXT$0",
            "};"
        ],
        "description": "Create an enumeration with specified integer type"
    },
    "union": {
        "prefix": "union",
        "body": [
            "const ${1:name} = union(${2:enum}) {",
            "\t$TM_SELECTED_TEXT$0",
            "};"
        ],
        "description": "Create a tagged union type"
    },

    // Loops

    "for value": {
        "prefix": "for_value",
        "body": [
            "for ($2) |${1:v}| {",
            "\t$TM_SELECTED_TEXT$0",
            "}"
        ],
        "description": "Create a for loop iterating over values"
    },
    "for value index": {
        "prefix": "for_value_index",
        "body": [
            "for ($3, 0..) |${1:v}, ${2:i}| {",
            "\t$TM_SELECTED_TEXT$0",
            "}"
        ],
        "description": "Create a for loop with both value and index"
    },
    "for inline": {
        "prefix": "for_inline",
        "body": [
            "inline for ($2) |${1:v}| {",
            "\t$TM_SELECTED_TEXT$0",
            "}"
        ],
        "description": "Create an inline for loop"
    },
    "for label": {
        "prefix": "for_label",
        "body": [
            "${1:label}: for ($3) |${2:v}| {",
            "\t$TM_SELECTED_TEXT$0",
            "}"
        ],
        "description": "Create a labeled for loop"
    },
    "for else": {
        "prefix": "for_else",
        "body": [
            "for ($2) |${1:v}| {",
            "\t$TM_SELECTED_TEXT$0",
            "\tbreak true;",
            "} else false;"
        ],
        "description": "Create a for loop with else branch"
    },
    "while": {
        "prefix": "while",
        "body": [
            "while ($1)${2: : ()} {",
            "\t$TM_SELECTED_TEXT$0",
            "}"
        ],
        "description": "Create a while loop"
    },
    "while else": {
        "prefix": "while_else",
        "body": [
            "while ($1)${2: : ()} {",
            "\t$TM_SELECTED_TEXT$0",
            "\tbreak true;",
            "} else false;"
        ],
        "description": "Create a while loop with else branch"
    },
    "while option": {
        "prefix": "while?",
        "body": [
            "while ($2) |${1:v}| {",
            "\t$TM_SELECTED_TEXT$0",
            "} else |err| {",
            "\t",
            "}"
        ],
        "description": "Create a while loop for optional values with error handling"
    },
    "while label": {
        "prefix": "while_label",
        "body": [
            "${1:label}: while ($2)${3: : ()} {",
            "\t$TM_SELECTED_TEXT$0",
            "\twhile ($4)${5: : ()} {",
            "\t\tbreak :${1:label};",
            "\t}",
            "}"
        ],
        "description": "Create a labeled while loop with nested break"
    },
    "while inline": {
        "prefix": "while_inline",
        "body": [
            "inline while ($1)${2: : ()} {",
            "\t$TM_SELECTED_TEXT$0",
            "}"
        ],
        "description": "Create an inline while loop"
    },
    
    // Array and Lists
    
    "list": {
        "prefix": "list",
        "body": [
            ".{$TM_SELECTED_TEXT$0};"
        ],
        "description": "Create an anonymous list literal"
    },
    "array init": {
        "prefix": "array_init",
        "body": [
            "&[_${1::sentinel}]${2:type}{$0};"
        ],
        "description": "Initialize an array with optional sentinel"
    },
    "array list": {
        "prefix": "array_list",
        "body": [
            "var ${1:name} = std.ArrayList(${2:type}).init(${0:allocator});"
        ],
        "description": "Create a dynamic array list"
    },
    "fixed array list": {
        "prefix": ["fixed_array_list", "array_list_length"],
        "body": [
            "var ${1:name} = std.ArrayList(${2:type}).initCapacity(${3:allocator}, ${0:length});"
        ],
        "description": "Create an array list with fixed capacity"
    },
    "to owned slice": {
        "prefix": "to_owned_slice",
        "body": [
            "${0:${TM_SELECTED_TEXT:arrayList}}.toOwnedSlice();"
        ],
        "description": "Convert ArrayList to owned slice"
    },
    "string hash map": {
        "prefix": "string_hash_map",
        "body": [
            "var ${1:name} = std.StringHashMap(${2:type}).init(${0:allocator});"
        ],
        "description": "Create a hash map with string keys"
    },
    "sort": {
        "prefix": "sort",
        "body": [
            "std.mem.sort(${1:type}, ${2:${TM_SELECTED_TEXT}}, {}, std.sort.${3|asc,desc|}($0));"
        ],
        "description": "Sort slice using std.sort"
    },

    // Memory Management

    "general purpose allocator": {
        "prefix": ["GPA", "general_purpose_allocator"],
        "body": [
            "var ${1:GPA} = std.heap.GeneralPurposeAllocator(.{}){};",
            "defer $1.deinit();",
            "const ${2:allocator} = $1.allocator();",
            "$0"
        ],
        "description": "Initialize a General Purpose Allocator (GPA)"
    },
    "arena allocator": {
        "prefix": "arena_allocator",
        "body": [
            "var ${1:arena} = std.heap.ArenaAllocator.init(${2:std.heap.page_allocator});",
            "defer $1.deinit();",
            "const ${3:allocator} = $1.allocator();",
            "$0"
        ],
        "description": "Initialize an Arena Allocator"
    },
    "fixed buffer allocator": {
        "prefix": ["FBA", "fixed_buffer_allocator"],
        "body": [
            "var ${1:buffer}: [${2:length}]${3:type} = undefined;",
            "var ${4:FBA} = std.heap.FixedBufferAllocator.init(&$1);",
            "const ${5:allocator} = $4.allocator();",
            "$0"
        ],
        "description": "Initialize a Fixed Buffer Allocator (FBA)"
    },

    // Control Flow

    "if": {
        "prefix": "if",
        "body": [
            "if ($1) {",
            "\t$TM_SELECTED_TEXT$0",
            "}"
        ],
        "description": "Create an if statement"
    },
    "if else": {
        "prefix": "if_else",
        "body": [
            "if ($1) {",
            "\t$TM_SELECTED_TEXT$0",
            "} else {",
            "\t",
            "}"
        ],
        "description": "Create an if-else statement"
    },
    "if else option": {
        "prefix": "if_else?",
        "body": [
            "if ($1) |v| {",
            "\t$TM_SELECTED_TEXT$0",
            "} else |err| switch(err) {",
            "\t => ,",
            "\telse => ,",
            "}"
        ],
        "description": "Create an if-else for optional values with error handling"
    },
    "switch": {
        "prefix": "switch",
        "body": [
            "switch ($1) {",
            "\t$2 => $3,",
            "\telse => $0,",
            "}"
        ],
        "description": "Create a switch statement"
    },
    "orelse": {
        "prefix": "orelse",
        "body": [
            "orelse return $0;"
        ],
        "description": "Handle null with orelse return"
    },

    // Error Handling
    
    "try": {
        "prefix": "try",
        "body": [
            "try ${1:${TM_SELECTED_TEXT/(.*);$/$1/}};$0"
        ],
        "description": "Try an expression that may return an error"
    },
    "catch": {
        "prefix": "catch",
        "body": [
            "${TM_SELECTED_TEXT/(.*);$/$1/} catch ${0:unreachable};"
        ],
        "description": "Catch and handle errors from an expression"
    },
    "defer": {
        "prefix": "defer",
        "body": [
            "defer {",
            "\t$TM_SELECTED_TEXT$0",
            "}"
        ],
        "description": "Create a defer block"
    },
    "error defer": {
        "prefix": "errdefer",
        "body": [
            "errdefer {",
            "\t$TM_SELECTED_TEXT$0",
            "}"
        ],
        "description": "Create an errdefer block"
    },
    "error": {
        "prefix": "error",
        "body": [
            "error.${0:Error}",
        ],
        "description": "Create an error value"
    },
    "error set": {
        "prefix": "error_set",
        "body": [
            "error {",
            "\t${1:Error},$0",
            "};"
        ],
        "description": "Define an error set"
    },

    // Testing

    "test": {
        "prefix": "test",
        "body": [
            "test ${1:\"name\"} {",
            "\t${0:const allocator = std.testing.allocator;}",
            "}"
        ],
        "description": "Create a test block"
    },
    "expect": {
        "prefix": "expect",
        "body": "try std.testing.${1|expect,expectApproxEqAbs,expectApproxEqRel,expectEqual,expectEqualDeep,expectEqualSentinel,expectEqualSlices,expectEqualStrings,expectError,expectFmt,expectStringEndsWith,expectStringStartsWith|}($0);",
        "description": "Add a test expectation using std.testing"
    },

    // Assembly

    "asm": {
        "prefix": "asm",
        "body": [
            "asm${1|volatile, |} (",
            "\t$TM_SELECTED_TEXT$0",
            ")"
        ],
        "description": "Insert inline assembly code"
    },
    
    // File Information

    "file name": {
        "prefix": "filename",
        "body": "${TM_FILENAME}",
        "description": "Insert current file name with extension"
    },
    "file name base": {
        "prefix": "filenamebase",
        "body": "${TM_FILENAME_BASE}",
        "description": "Insert current file name without extension"
    },
    "directory": {
        "prefix": "directory",
        "body": "${TM_DIRECTORY}",
        "description": "Insert current directory path"
    },
    "absolute path": {
        "prefix": "abspath",
        "body": "${TM_FILEPATH}",
        "description": "Insert absolute path of current file"
    },
    "relative path": {
        "prefix": "relpath",
        "body": "${RELATIVE_FILEPATH}",
        "description": "Insert workspace-relative path of current file"
    },
    "workspace name": {
        "prefix": "workspacename",
        "body": "${WORKSPACE_NAME}",
        "description": "Insert current workspace name"
    },
    "workspace folder": {
        "prefix": "workspacefolder",
        "body": "${WORKSPACE_FOLDER}",
        "description": "Insert current workspace root folder path"
    },
    
    // Random values

    "random value": { 
        "prefix": "randomvalue",
        "body": "${RANDOM}",
        "description": "Insert random number"
    },
    "random hex": {
        "prefix": "randomhex",
        "body": "${RANDOM_HEX}",
        "description": "Insert random hexadecimal value"
    },
    "uuid": {
        "prefix": "uuid",
        "body": "${UUID}",
        "description": "Insert a UUID (Universal Unique Identifier)"
    },

    // Template from https://github.com/gaskam-com/zig-utils

    "zig utils": {
        "prefix": "zigutils",
            "\t}",
            "",
            "\t/// Reads a line and removes the newline characters(\\n, and \\r\\n for windows)",
            "\tfn read(self: Self) ![]const u8 {",
            "\t\tvar buffer = std.ArrayList(u8).init(self.allocator);",
            "\t\terrdefer buffer.deinit();",
            "\t\tself.reader.streamUntilDelimiter(buffer.writer(), '\\n', null) catch |err| {",
            "\t\t\tif (err != error.EndOfStream) return err;",
            "\t\t};",
            "\t\tif (builtin.target.os.tag == .windows and buffer.getLastOrNull() == '\\r') _ = buffer.pop();",
            "\t\treturn buffer.toOwnedSlice();",
            "\t}",
            "",
            "\t/// Parses a level 1 type",
            "\t/// Only accepts Int, Float and string([]const u8) types",
            "\tfn parseType(self: Self, comptime ReturnType: type, buf: []const u8) !ReturnType {",
            "\t\treturn switch (@typeInfo(ReturnType)) {",
            "\t\t\t.Int => std.fmt.parseInt(ReturnType, buf, 10),",
            "\t\t\t.Float => std.fmt.parseFloat(ReturnType, buf),",
            "\t\t\t.Bool => try std.fmt.parseInt(u1, buf, 10) != 0,",
            "\t\t\t// Asserts the type is []const u8",
            "\t\t\t.Pointer => blk: {",
            "\t\t\t\tif (ReturnType != []const u8) return error.UnsupportedType;",
            "\t\t\t\tbreak :blk self.allocator.dupe(u8, buf);",
            "\t\t\t},",
            "\t\t\telse => error.UnsupportedType,",
            "\t\t};",
            "\t}",
            "",
            "\t/// Parses one line to a value(only supports int or float types)",
            "\t/// Asserts there is a numeric value",
            "\tfn readValue(self: Self, comptime ReturnType: type) !ReturnType {",
            "\t\tconst value = try read(self);",
            "\t\tdefer self.allocator.free(value);",
            "\t\treturn self.parseType(ReturnType, value);",
            "\t}",
            "",
            "\t/// Reads all elements on a line, splits them by `delimiter` and parses them",
            "\t/// Asserts there is atlease 1 element",
            "\tfn readList(self: Self, comptime ReturnType: type, delimiter: u8) ![]ReturnType {",
            "\t\tconst line = try self.read();",
            "\t\tdefer self.allocator.free(line);",
            "\t\tvar values = std.mem.splitScalar(u8, line, delimiter);",
            "\t\tvar output = std.ArrayList(ReturnType).init(self.allocator);",
            "\t\terrdefer output.deinit();",
            "",
            "\t\twhile (values.next()) |v| {",
            "\t\t\ttry output.append(try self.parseType(ReturnType, v));",
            "\t\t}",
            "\t\treturn try output.toOwnedSlice();",
            "\t}",
            "",
            "\t/// Reads N elements on a line, splits them by `delimiter` and parses them",
            "\t/// Asserts there is atlease 1 element",
            "\tfn readNElements(self: Self, comptime ReturnType: type, delimiter: u8, amount: usize) ![]ReturnType {",
            "\t\tconst line = try self.read();",
            "\t\tdefer self.allocator.free(line);",
            "\t\tvar values = std.mem.splitScalar(u8, line, delimiter);",
            "\t\tvar output = try std.ArrayList(ReturnType).initCapacity(self.allocator, amount);",
            "\t\terrdefer output.deinit();",
            "",
            "\t\tfor (0..amount) |_| {",
            "\t\t\tconst v = values.next() orelse unreachable;",
            "\t\t\toutput.appendAssumeCapacity(try self.parseType(ReturnType, v));",
            "\t\t}",
            "",
            "\t\treturn try output.toOwnedSlice();",
            "\t}",
            "",
            "\t/// Returns the amount of lens needed for shape inside of a type",
            "\tinline fn readDepth(self: Self, comptime ReturnType: type) !comptime_int {",
            "\t\tconst typeInfo = @typeInfo(ReturnType);",
            "\t\treturn switch (typeInfo) {",
            "\t\t\t.Int, .Float, .Bool => 0,",
            "\t\t\t.Array => 0,",
            "\t\t\t.Pointer => blk: {",
            "\t\t\t\tconst childType = typeInfo.Pointer.child;",
            "\t\t\t\tif (ReturnType == []const u8) {",
            "\t\t\t\t\tbreak :blk 0;",
            "\t\t\t\t}",
            "\t\t\t\tswitch (@typeInfo(childType)) {",
            "\t\t\t\t\t.Int, .Float => break :blk 1,",
            "\t\t\t\t\t.Pointer, .Struct => {",
            "\t\t\t\t\t\tif (ReturnType == []const u8) {",
            "\t\t\t\t\t\t\tbreak :blk 1;",
            "\t\t\t\t\t\t}",
            "\t\t\t\t\t\tbreak :blk 1 + try self.readDepth(childType);",
            "\t\t\t\t\t},",
            "\t\t\t\t\telse => return error.UnsupportedType,",
            "\t\t\t\t}",
            "\t\t\t},",
            "\t\t\t.Struct => {",
            "\t\t\t\tcomptime var depth: usize = 0;",
            "\t\t\t\tinline for (typeInfo.Struct.fields) |field| {",
            "\t\t\t\t\tconst fieldInfo = @typeInfo(field.type);",
            "\t\t\t\t\tswitch (fieldInfo) {",
            "\t\t\t\t\t\t.Int, .Float => {},",
            "\t\t\t\t\t\t.Pointer, .Struct => {",
            "\t\t\t\t\t\t\tdepth += try self.readDepth(field.type);",
            "\t\t\t\t\t\t},",
            "\t\t\t\t\t\telse => return error.UnsupportedType,",
            "\t\t\t\t\t}",
            "\t\t\t\t}",
            "\t\t\t\treturn depth;",
            "\t\t\t},",
            "\t\t\telse => error.UnsupportedType,",
            "\t\t};",
            "\t}",
            "",
            "\t/// Reads a complex type",
            "\t/// The shape needs to contain the required amount of lens (you can check the required amount with `readDepth`)",
            "\t/// The caller is responsible for freeing all the memory",
            "\tfn readType(self: Self, comptime ReturnType: type, shape: ?[]const usize, delimiter: u8) !ReturnType {",
            "\t\tconst typeInfo = @typeInfo(ReturnType);",
            "\t\tswitch (typeInfo) {",
            "\t\t\t.Int, .Float, .Bool => {",
            "\t\t\t\treturn self.readValue(ReturnType);",
            "\t\t\t},",
            "\t\t\t.Pointer, .Array => {",
            "\t\t\t\tconst childType = if (typeInfo == .Pointer) typeInfo.Pointer.child else typeInfo.Array.child;",
            "\t\t\t\tif (ReturnType == []const u8) {",
            "\t\t\t\t\treturn self.read();",
            "\t\t\t\t}",
            "\t\t\t\tswitch (@typeInfo(childType)) {",
            "\t\t\t\t\t.Int, .Float, .Bool => {",
            "\t\t\t\t\t\tif (typeInfo == .Pointer) {",
            "\t\t\t\t\t\t\treturn self.readNElements(childType, delimiter, shape.?[0]);",
            "\t\t\t\t\t\t} else {",
            "\t\t\t\t\t\t\tconst values = try self.readNElements(childType, delimiter, typeInfo.Array.len);",
            "\t\t\t\t\t\t\tdefer self.allocator.free(values);",
            "\t\t\t\t\t\t\treturn values[0..typeInfo.Array.len].*;",
            "\t\t\t\t\t\t}",
            "\t\t\t\t\t},",
            "\t\t\t\t\t.Pointer, .Struct, .Array => {",
            "\t\t\t\t\t\tif (ReturnType == []const u8) {",
            "\t\t\t\t\t\t\treturn try self.read();",
            "\t\t\t\t\t\t}",
            "",
            "\t\t\t\t\t\tconst amount = if (typeInfo == .Pointer) shape.?[0] else typeInfo.Array.len;",
            "\t\t\t\t\t\tvar values = try std.ArrayList(childType).initCapacity(self.allocator, amount);",
            "\t\t\t\t\t\terrdefer values.deinit();",
            "\t\t\t\t\t\tfor (amount) |_| {",
            "\t\t\t\t\t\t\tvalues.appendAssumeCapacity(try self.readType(childType, (shape orelse @as([]const usize, &[_]usize{0}))[1..], delimiter));",
            "\t\t\t\t\t\t}",
            "\t\t\t\t\t\tif (typeInfo == .Pointer) {",
            "\t\t\t\t\t\t\treturn values.toOwnedSlice();",
            "\t\t\t\t\t\t} else {",
            "\t\t\t\t\t\t\tconst result = try values.toOwnedSlice();",
            "\t\t\t\t\t\t\tdefer self.allocator.free(result);",
            "\t\t\t\t\t\t\treturn result[0..typeInfo.Array.len].*;",
            "\t\t\t\t\t\t}",
            "\t\t\t\t\t},",
            "\t\t\t\t\telse => return error.UnsupportedType,",
            "\t\t\t\t}",
            "\t\t\t},",
            "\t\t\t.Struct => {",
            "\t\t\t\tconst s = try self.allocator.create(ReturnType);",
            "\t\t\t\tdefer self.allocator.destroy(s);",
            "\t\t\t\tvar line: []const u8 = \"\";",
            "\t\t\t\tvar currentIndex: usize = 0;",
            "\t\t\t\tvar subShape = shape.?;",
            "\t\t\t\tinline for (typeInfo.Struct.fields) |field| {",
            "\t\t\t\t\tconst fieldInfo = @typeInfo(field.type);",
            "\t\t\t\t\tswitch (fieldInfo) {",
            "\t\t\t\t\t\t.Int, .Float, .Bool => {",
            "\t\t\t\t\t\t\tif (line.len == currentIndex) {",
            "\t\t\t\t\t\t\t\tline = try self.read();",
            "\t\t\t\t\t\t\t}",
            "\t\t\t\t\t\t\tconst index = std.mem.indexOfScalarPos(u8, line, currentIndex, delimiter);",
            "\t\t\t\t\t\t\tif (index == null) {",
            "\t\t\t\t\t\t\t\t@field(s, field.name) = try self.parseType(field.type, line[currentIndex..]);",
            "\t\t\t\t\t\t\t\tself.allocator.free(line);",
            "\t\t\t\t\t\t\t\tcurrentIndex = 0;",
            "\t\t\t\t\t\t\t\tline = \"\";",
            "\t\t\t\t\t\t\t} else {",
            "\t\t\t\t\t\t\t\t@field(s, field.name) = try self.parseType(field.type, line[currentIndex..index.?]);",
            "\t\t\t\t\t\t\t\tcurrentIndex = index.? + 1;",
            "\t\t\t\t\t\t\t}",
            "\t\t\t\t\t\t},",
            "\t\t\t\t\t\t.Pointer, .Struct => {",
            "\t\t\t\t\t\t\tself.allocator.free(line);",
            "\t\t\t\t\t\t\tline = \"\";",
            "\t\t\t\t\t\t\tcurrentIndex = 0;",
            "\t\t\t\t\t\t\t@field(s, field.name) = try self.readType(field.type, subShape, delimiter);",
            "\t\t\t\t\t\t\tif (subShape.len > 0)",
            "\t\t\t\t\t\t\t\tsubShape = subShape[try self.readDepth(field.type)..];",
            "\t\t\t\t\t\t},",
            "\t\t\t\t\t\telse => return error.UnsupportedType,",
            "\t\t\t\t\t}",
            "\t\t\t\t}",
            "\t\t\t\tself.allocator.free(line);",
            "\t\t\t\treturn s.*;",
            "\t\t\t},",
            "\t\t\telse => return error.UnsupportedType,",
            "\t\t}",
            "\t}",
            "};",
            "",
            "pub fn main() !void {",
            "\tvar arena = std.heap.ArenaAllocator.init(std.heap.page_allocator);",
            "\tdefer arena.deinit();",
            "\tconst allocator = arena.allocator();",
            "\tconst stdin = std.io.getStdIn().reader();",
            "\tconst lineReader = LineReader.init(allocator, stdin);",
            "",
            "\t// const Matrix = struct {",
            "\t//\t content: [][]i32,",
            "\t//\t text: []const u8,",
            "\t// };",
            "",
            "\t// const matrix = try lineReader.readType([]Matrix, &[_]usize{ 2, 3, 3 }, ' ');",
            "",
            "\t// std.debug.print(\"Matrix: {any}\", .{matrix});",
            "",
            "\t// @compileLog(@typeInfo([5]u32));",
            "",
            "\tconst array = try lineReader.readType([5]bool, null, ' ');",
            "",
            "\tconst ttt = try lineReader.read();",
            "\t_ = ttt;",
            "",
            "\tstd.debug.print(\"Array: {any}\", .{array});",
            "}",
            "",
            "test \"LineReader\" {",
            "\tconst allocator = std.testing.allocator;",
            "\tconst input = try std.fs.cwd().openFile(\"tests/LineReader.input\", .{});",
            "\tdefer input.close();",
            "",
            "\tvar lineReader = LineReader.init(allocator, input.reader());",
            "\tconst line = try lineReader.readType([]const u8, &[_]usize{}, ' ');",
            "\tdefer allocator.free(line);",
            "\tconst bools = try lineReader.readType([5]bool, null, ' ');",
            "\tconst numbers = try lineReader.readNElements(i32, ' ', 3);",
            "\tdefer allocator.free(numbers);",
            "\tconst floats = try lineReader.readList(f64, ',');",
            "\tdefer allocator.free(floats);",
            "\tconst strings = try lineReader.readList([]const u8, ' ');",
            "\tdefer {",
            "\t\tfor (strings) |string| {",
            "\t\t\tallocator.free(string);",
            "\t\t}",
            "\t\tallocator.free(strings);",
            "\t}",
            "\tconst emptyStrings = try lineReader.readList([]const u8, ' ');",
            "\tdefer {",
            "\t\t// Not needed: (as there is nothing to free)",
            "\t\t// for (emptyStrings) |string| {",
            "\t\t//\t allocator.free(string);",
            "\t\t// }",
            "\t\tallocator.free(emptyStrings);",
            "\t}",
            "",
            "\tconst Matrix = struct {",
            "\t\tcontent: [][]i32,",
            "\t\ttext: []const u8,",
            "\t};",
            "",
            "\tconst matrix = try lineReader.readType([]Matrix, &[_]usize{ 2, 5, 5 }, ' ');",
            "\tdefer {",
            "\t\tfor (matrix) |structs| {",
            "\t\t\tfor (structs.content) |row| {",
            "\t\t\t\tallocator.free(row);",
            "\t\t\t}",
            "\t\t\tallocator.free(structs.content);",
            "\t\t\tallocator.free(structs.text);",
            "\t\t}",
            "\t\tallocator.free(matrix);",
            "\t}",
            "",
            "\tconst SuperValue = struct { n: i32, s: i32, a: []const u8, b: []const u8 };",
            "\tconst values = try lineReader.readType([]SuperValue, &[_]usize{3}, ' ');",
            "\tdefer {",
            "\t\tfor (values) |superValue| {",
            "\t\t\tallocator.free(superValue.a);",
            "\t\t\tallocator.free(superValue.b);",
            "\t\t}",
            "\t\tallocator.free(values);",
            "\t}",
            "",
            "\tconst ArrayStruct = struct { a: []i32, b: []i32 };",
            "",
            "\tconst NestedStruct = struct {",
            "\t\tstruct1: ArrayStruct,",
            "\t\tstruct2: ArrayStruct,",
            "\t};",
            "",
            "\tconst nestedStruct = try lineReader.readType([]NestedStruct, &[_]usize{ 2, 1, 2, 3, 4 }, ' ');",
            "\tdefer {",
            "\t\tfor (nestedStruct) |nested| {",
            "\t\t\tallocator.free(nested.struct1.a);",
            "\t\t\tallocator.free(nested.struct1.b);",
            "\t\t\tallocator.free(nested.struct2.a);",
            "\t\t\tallocator.free(nested.struct2.b);",
            "\t\t}",
            "\t\tallocator.free(nestedStruct);",
            "\t}",
            "",
            "\ttry std.testing.expectEqualStrings(line, \"Hello world\");",
            "\ttry std.testing.expectEqualDeep(bools, (&[5]bool{ true, false, true, false, true }).*);",
            "\ttry std.testing.expectEqualDeep(numbers, &[_]i32{ 123, 456, 789 });",
            "\ttry std.testing.expectEqualDeep(floats, &[_]f64{ -2.5, 2.8, 9.7, 3.14 });",
            "\ttry std.testing.expectEqualDeep(strings, &[_][]const u8{ \"the\", \"new\", \"hello\", \"world\" });",
            "\ttry std.testing.expectEqualDeep(emptyStrings, &[_][]const u8{\"\"});",
            "",
            "\tconst expectedMatrix = &[_]Matrix{ Matrix{",
            "\t\t.content = @constCast(&[_][]i32{",
            "\t\t\t@constCast(&[_]i32{ 3, 4, 6, 8, 7 }),",
            "\t\t\t@constCast(&[_]i32{ 7, 8, 9, 5, 6 }),",
            "\t\t\t@constCast(&[_]i32{ 7, 8, 4, 2, 7 }),",
            "\t\t\t@constCast(&[_]i32{ 9, 7, 8, 6, 2 }),",
            "\t\t\t@constCast(&[_]i32{ 2, 5, 6, 8, 4 }),",
            "\t\t}),",
            "\t\t.text = \"hello world\",",
            "\t}, Matrix{",
            "\t\t.content = @constCast(&[_][]i32{",
            "\t\t\t@constCast(&[_]i32{ 7, 8, 9, 6, 5 }),",
            "\t\t\t@constCast(&[_]i32{ 1, 0, 2, 3, 6 }),",
            "\t\t\t@constCast(&[_]i32{ 8, 9, 6, 3, 2 }),",
            "\t\t\t@constCast(&[_]i32{ 7, 8, 9, 6, 5 }),",
            "\t\t\t@constCast(&[_]i32{ 1, 2, 5, 4, 7 }),",
            "\t\t}),",
            "\t\t.text = \"see you later\",",
            "\t} };",
            "\ttry std.testing.expectEqualDeep(matrix, expectedMatrix);",
            "",
            "\tconst expectedValues = &[_]SuperValue{",
            "\t\tSuperValue{ .n = 2, .s = 6, .a = \"mjalajdsfk\", .b = \"mladfsmljqslkf\" },",
            "\t\tSuperValue{ .n = 8, .s = 9, .a = \"qsdfjqmlfp\", .b = \"poaljmdflk\" },",
            "\t\tSuperValue{ .n = 98645, .s = 8, .a = \"apdlfkjqmd\", .b = \"mladjfqp\" },",
            "\t};",
            "\ttry std.testing.expectEqualDeep(values, expectedValues);",
            "",
            "\tconst expectedNestedStruct = &[_]NestedStruct{",
            "\t\tNestedStruct{",
            "\t\t\t.struct1 = ArrayStruct{ .a = @constCast(&[_]i32{1}), .b = @constCast(&[_]i32{ 1, 2 }) },",
            "\t\t\t.struct2 = ArrayStruct{ .a = @constCast(&[_]i32{ 1, 2, 3 }), .b = @constCast(&[_]i32{ 1, 2, 3, 4 }) },",
            "\t\t},",
            "\t\tNestedStruct{",
            "\t\t\t.struct1 = ArrayStruct{ .a = @constCast(&[_]i32{9}), .b = @constCast(&[_]i32{ 9, 8 }) },",
            "\t\t\t.struct2 = ArrayStruct{ .a = @constCast(&[_]i32{ 9, 8, 7 }), .b = @constCast(&[_]i32{ 9, 8, 7, 6 }) },",
            "\t\t},",
            "\t};",
            "",
            "\ttry std.testing.expectEqualDeep(nestedStruct, expectedNestedStruct);",
            "}"
        ],
        "description": "A set made to help parse input line per line",
        "isFileTemplate": true
    }
}